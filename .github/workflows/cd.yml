name: Continuous Deployment - Build, Deploy, and Test

on:
  push:
    branches:
      - main

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GAR_LOCATION: ${{ secrets.GAR_LOCATION }}
  GAR_REPOSITORY: ${{ secrets.GAR_REPOSITORY_NAME }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER_NAME }}
  GKE_ZONE: ${{ secrets.GKE_ZONE }}
  IMAGE_NAME: iris-api

jobs:
  build-and-push-image:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: 'read'
      id-token: 'write'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      id: auth
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    - name: Set up Cloud SDK
      uses: 'google-github-actions/setup-gcloud@v2'

    - name: Configure Docker
      run: gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev

    - name: Write SA key to file
      run: echo '${{ secrets.GCP_SA_KEY }}' > gcp_sa_key.json

    - name: Build Docker Image
      run: |
        DOCKER_BUILDKIT=1 docker build \
          --secret id=gcp-sa-key,src=gcp_sa_key.json \
          -t ${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          .

    - name: Remove SA key file
      if: always()
      run: rm -f gcp_sa_key.json

    - name: Push Docker Image to GAR
      run: docker push ${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

  deploy-to-gke:
    name: Deploy to GKE
    runs-on: ubuntu-latest
    needs: build-and-push-image
    permissions:
      contents: 'read'
      id-token: 'write'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      id: auth
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    - name: Set up GKE credentials
      uses: 'google-github-actions/get-gke-credentials@v2'
      with:
        cluster_name: ${{ env.GKE_CLUSTER }}
        location: ${{ env.GKE_ZONE }}
        
    - name: Prepare K8s Manifest
      run: |
        sed -i "s|IMAGE_PLACEHOLDER|${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}|g" k8s/deployment.yml
        
    - name: Deploy to GKE
      run: |
        kubectl apply -f k8s/deployment.yml
        kubectl apply -f k8s/hpa.yml
        echo "Deployment started. Waiting for rollout..."
        # Increased timeout to 5 minutes to be safe
        kubectl rollout status deployment/iris-api-deployment --timeout=5m
        
    - name: Show Service IP
      run: |
        echo "Deployments successful! Waiting for LoadBalancer IP..."
        kubectl get service iris-api-service

  stress-test-deployment:
    name: ⚡ Stress Test Deployment
    runs-on: ubuntu-latest
    needs: deploy-to-gke 

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install wrk and gcloud/kubectl
      run: |
        sudo apt-get update
        sudo apt-get install -y wrk
        
    - name: Authenticate to Google Cloud
      id: auth
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    - name: Set up GKE credentials
      uses: 'google-github-actions/get-gke-credentials@v2'
      with:
        cluster_name: ${{ env.GKE_CLUSTER }}
        location: ${{ env.GKE_ZONE }}

    - name: Get External IP and run test
      run: |
        echo "Waiting for External IP..."
        EXTERNAL_IP=""
        while [ -z $EXTERNAL_IP ]; do
          sleep 10
          EXTERNAL_IP=$(kubectl get service iris-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Current IP: $EXTERNAL_IP"
        done

        echo "✅ IP found: $EXTERNAL_IP"

        # --- THIS IS THE CRITICAL FIX ---
        echo "⌛ Waiting for Load Balancer to be ready (max 3 minutes)..."
        START_TIME=$SECONDS
        while true; do
          # Use curl with a 5-second timeout and check its exit code
          # -f (fail fast), -s (silent), -I (headers only)
          curl -fsI --connect-timeout 5 "http://$EXTERNAL_IP/health" > /dev/null
          CURL_EXIT_CODE=$?

          if [ $CURL_EXIT_CODE -eq 0 ]; then
            echo "✅ Load Balancer is ready!"
            break
          fi

          # Check for timeout (3 minutes)
          ELAPSED_TIME=$(($SECONDS - $START_TIME))
          if [ $ELAPSED_TIME -ge 180 ]; then
            echo "❌ ERROR: Load Balancer wait timed out after 3 minutes."
            exit 1
          fi

          # 7 = Connection refused. This is OK, we just retry.
          if [ $CURL_EXIT_CODE -eq 7 ]; then
             echo "Load Balancer not ready (Connection refused), retrying in 10s..."
          else
             echo "Load Balancer not ready (curl code: $CURL_EXIT_CODE), retrying in 10s..."
          fi
          sleep 10
        done
        # --- END OF FIX ---
        
        echo "--- Starting stress test (1000+ requests) ---"
        
        wrk -t4 -c150 -d30s -s tests/post.lua http://$EXTERNAL_IP/predict

        echo "--- Test complete. Checking HPA status: ---"
        kubectl get hpa iris-api-hpa

        echo "--- Checking Pod status: ---"
        kubectl get pods
